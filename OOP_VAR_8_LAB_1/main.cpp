/*
	Побудувати конкретний клас відповідно варіанту з врахуванням необхідності приховання даних.
	Якщо це не оговорено окремо, у кожному класі, що розробляеться, передбачити:
		-конструктори умовчання, з параметрами та копіювання;
		-за наявності динамічних полів, у тому числі символьних рядків довільної довжини, у конструкторах передбачити виділення пам'яті;
		- деструктор;
		- функції-селектори для доступу окремо до кожного поля;
		- дві функції для виведення на екран інформації про поточний стан об'екту; одна - у вигляді рядка зі значеннями кожного з полів через пропуск, друга - у вигляді назви класу і значення одного з полів, яке найкраще ідентифікуватиме об'ект; якщо клас містить масив, інформація про кожний елемент масиву подаеться окремим рядком у першій з фeнкцій,
		- функції-модифікатори окремо для кожного з полів з повертанням посилання на модифікований об'ект. У тестовому прикладі створити три об'екти заданого відповідно варіанту типу з використанням усіх визначених конструкторів. Для створення об'екта з використанням конструктора з параметрами, дані для нього уводити з клавіатури.
	У тестовому прикладі створити об'екти типу «Товар» та «Постачальник» відповідно загальним вимогам і вивести інформацію про них у повному та скороченому вигляді.
  */
#include "Provider.h"
#include "Goods.h"
#include "Food.h"
#include "IndustrialGoods.h"
#include<windows.h>
#include "Warehouse.h"

using namespace std;

int main()
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	Warehouse WR1(3), WR2(2);
	Provider prov = Provider("Babki Industries", "Ukraine", "+380630000777");
	cout << prov;
	Goods g("Kampukter", 100500, 33333, prov);
	cout << "g: ";
	g.Put();
	g.PutFull();
	cout << "Postfix ";
	(g++).PutFull();
	cout << "After postfix ";
	g.PutFull();
	cout << "Prefix ";
	(++g).PutFull();
	Goods g1("Kampukter", 100500, 2222, prov);
	cout << "g1: ";
	g1.PutFull();
	Goods g2("NeKampukter", 100, 2, prov);
	cout << "g2: ";
	g2.PutFull();
	Goods* ga = new Goods[3];
	ga[0] = g;
	ga[1] = g1;
	ga[2] = g2;
	Goods* gb = new Goods[2];
	gb[0] = g2;
	gb[1] = g1;
	WR1.addGoods(ga, 3);
	WR2.addGoods(gb, 2);
	cout << "Equal plus (g+g1) ";
	(g + g1).PutFull();
	cout << "Not equal plus (g+g2) ";
	(g = g + g2).PutFull();
	cout << "g > g2 ";
	cout << (g > g2) << endl;
	cout << "g == g1 ";
	cout << (g == g1) << endl;
	cout << WR1 << endl;
	cout << WR2 << endl;
	system("pause");
}
