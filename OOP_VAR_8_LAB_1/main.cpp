/*
	Побудувати конкретний клас відповідно варіанту з врахуванням необхідності приховання даних.
	Якщо це не оговорено окремо, у кожному класі, що розробляеться, передбачити:
		-конструктори умовчання, з параметрами та копіювання;
		-за наявності динамічних полів, у тому числі символьних рядків довільної довжини, у конструкторах передбачити виділення пам'яті;
		- деструктор;
		- функції-селектори для доступу окремо до кожного поля;
		- дві функції для виведення на екран інформації про поточний стан об'екту; одна - у вигляді рядка зі значеннями кожного з полів через пропуск, друга - у вигляді назви класу і значення одного з полів, яке найкраще ідентифікуватиме об'ект; якщо клас містить масив, інформація про кожний елемент масиву подаеться окремим рядком у першій з фeнкцій,
		- функції-модифікатори окремо для кожного з полів з повертанням посилання на модифікований об'ект. У тестовому прикладі створити три об'екти заданого відповідно варіанту типу з використанням усіх визначених конструкторів. Для створення об'екта з використанням конструктора з параметрами, дані для нього уводити з клавіатури.
	У тестовому прикладі створити об'екти типу «Товар» та «Постачальник» відповідно загальним вимогам і вивести інформацію про них у повному та скороченому вигляді.
  */
#include "Provider.h"
#include "Goods.h"
#include "Food.h"
#include "IndustrialGoods.h"
#include<windows.h>

using namespace std;

int main()
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	Provider p = Provider();
	p.Put();
	p.PutFull();
	string a, b, c;
	getline(cin, a);
	getline(cin, b);
	getline(cin, c);
	Provider prov = Provider(a, b, c);
	prov.Put();
	prov.PutFull();
	Goods good = Goods();
	good.Put();
	good.PutFull();
	int k, m;
	getline(cin, a);
	cin >> k >> m;
	Goods g(a, k, m, prov);
	g.Put();
	g.PutFull();
	cout << g.alarm() << endl;
	IndustrialGoods ID(g, 2, 0);
	cout << ID.alarm() << endl;
	Food foo(g, 10, 3, 2017, 3);
	cout << foo.alarm() << endl;
	system("pause");
}
